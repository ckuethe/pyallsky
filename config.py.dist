import cv2  # только если цветная камера

name = 'Имя Фамилия'

ccd = {
	'name':		'ZWO CCD ASI178MC',
	'binning':	2,
	'avgMin':	55,
	'avgMax':	150,
	'expMin':	0.0001,
	'expMax':	45.,
	'bits':		16,
	'center':   75,                     # для замера среднего считаем только N% центра кадра
#	'cfa':		cv2.COLOR_BayerBG2RGB,  # только если цветная камера
}

# варианты дебаеризации
#  cv2.COLOR_BayerBG2RGB
#  cv2.COLOR_BayerGB2RGB
#  cv2.COLOR_BayerRG2RGB
#  cv2.COLOR_BayerGR2RGB

publish = {
#	'jpg': 'https://oleg.milantiev.com/allsky/publish/jpg/',	# публикация каждого jpg на другой сайт
}

processing = {
#	'crop': {						# Crop (ROI) кадра с указанием колва обрезаемых пикселей
#		'left':   800,
#		'right':  800,
#		'top':    0,
#		'bottom': 0,
#	},
#	'logo': {						# Если нужно лого
#		'fileName': '/sdcard/html/allsky_logo.jpg', # Картинка размером с итоговый кадр после ROI (если использовался)
#		'x': 0,
#		'y': 0,
#   },
#	'wb': 'gain',					# gain - вручную, simple - SimpleWB из OpenCV, gray - GreyworldWB
#	'wbGains' : {
#		'r': 0.85,
#		'g': 0.65,
#		'b': 0.990,
#	},
}

sensors = {
	'bme280': {						# Два датчика BME280. 0 и 1
		0: 'Улица',
		1: 'Купол'
	},
	'ads1115': {					# 4 канала АЦП ADS1115
		0: {
			'name': '24В',
			'divider': 716.4,
		},
		1: {
			'name': '12В',
			'divider': 800,
		},
	}
}

keogram = {
	'column':	640,					# колонка 640 каждого кадра будет строить keogram
	'height':	960,					# высота итогового изображения keogram. Обычно совпадает с высотой исходного кадра
}

# Аннотации изображения, если нужны (дата / время, среднее, выдержка)
annotations = [
	{
		'type':		'text',				# Тип аннотации ('text', 'datetime', 'avg', 'exposure')
		'text':		'AllSky',			# Текст
		'x':		300,				# координаты ЛВУ. В пикселях
		'y':		0,
		'size':		30,					# размер шрифта
		'color':	(255,255,255,128),	# цвет букв
	},
	{
		'type':		'datetime',
		'format':	'%d.%m.%Y',			# Формат строки strftime()
		'x':		0,
		'y':		0,
		'size':		30,
		'color':	(255,255,255,128),
	},
	{
		'type':		'datetime',
		'format':	'%H:%M',
		'x':		0,
		'y':		35,
		'size':		30,
		'color':	(255,255,255,255),
	},
	{
		'type':		'avg',
		'format':	'CCD_avg: {:.0f}',				# Формат строки "%d".format(xxx)
		'x':		0,
		'y':		100,
		'size':		20,
		'color':	(255,255,255,128),
	},
	{
		'type':		'exposure',
		'format':	'EXP: {:.4f}',
		'x':		0,
		'y':		120,
		'size':		20,
		'color':	(255,255,255,128),
	},
]

archive = {
	'jpg':		7,				# Хранить архив жпегов 7 дней
	'fit':		3,				# Хранить архив fit 3 дня
	'sensors':	30,				# Хранить архив данных сенсоров 30 дней
	'video':    30,             # Хранить архив видео 30 дней
}

video = {
	'width':	1024,
	'height':	768,
}

# http://integrator.adior.ru/index.php/orangepi/478-orange-pi-gpio-sysfs
relay = [
	{
		'name':			'Реле 1',
		'gpio':			'17',		# '/sys/class/gpio/gpio17/value',
		'hotter':		'yes',		# это реле - обогрев подкупольного
		'limitTemp':	29.5,		# предельная температура подкупольного пространства, выше которой обогрев не включается
	},
	{
		'name':			'Реле 2',
		'gpio':			'18',
	},
]

db = {
	'host':		'localhost',
	'user':		'root',
	'passwd':	'master',
	'database':	'allsky',
}

path = {
	'web':		'/var/www/html/',
	'ffmpeg':	'/usr/bin/ffmpeg',
}

import logging

log = {
	'path':		'/var/log/allsky.log',	# путь до лога. И уровень болтливости (debug = максимальный)
	'level':	logging.DEBUG,			# менее подробные: logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL
}


### дальше не править

if (path['web'][-1] != '/'):
	path['web'] += '/'

path['jpg'] = path['web'] +'snap/'
path['keogram'] = path['web'] +'keogram/'
path['video'] = path['web'] +'video/'
path['video-demand'] = path['web'] +'video-demand/'
path['fit'] = path['web'] + 'fits/'
